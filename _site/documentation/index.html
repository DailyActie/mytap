<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>MyTAP by hepabolu</title>

    <link rel="stylesheet" href="/assets/css/style.css?v=1612e3404a32f3e5d2a80ca79420ad27758705e3">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>MyTAP</h1>
        <p>MySQL Unit Testing Suite</p>

        
          <p class="view"><a href="http://github.com/hepabolu/mytap">View the Project on GitHub <small></small></a></p>
        

        

        
      </header>
      <section>

      <p>MyTap 
<strong>Version: 0.05</strong></p>

<p>MyTAP is a unit testing framework for MySQL 5.x written using fuctions and
procedures. It includes a collection of TAP-emitting assertion functions, as
well as the ability to integrate with other TAP-emitting test frameworks.</p>

<h1 id="installation">Installation</h1>

<p>To install MyTAP into a MySQL database, just run <code class="highlighter-rouge">mytap.sql</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mysql -u root &lt; mytap.sql
</code></pre>
</div>

<p>This will install all of the assertion functions, as well as a cache table,
into a database named “tap”.</p>

<h1 id="mytap-test-scripts">MyTAP Test Scripts</h1>

<p>Here’s an example of how to write a MyTAP test script:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>-- Start a transaction.
BEGIN;

-- Plan the tests.
SELECT tap.plan(1);

-- Run the tests.
SELECT tap.pass( 'My test passed, w00t!' );

-- Finish the tests and clean up.
CALL tap.finish();
ROLLBACK;
</code></pre>
</div>

<p>Note how the TAP test functions are reference from another database so as to
keep them separate from your application database.</p>

<p>Now you’re ready to run your test script!</p>

<div class="highlighter-rouge"><pre class="highlight"><code>% mysql -u root --disable-pager --batch --raw --skip-column-names --unbuffered --database test --execute 'source test.sql'
1..1
ok 1 - My test passed, w00t!
</code></pre>
</div>

<p>Yeah, that’s rather a lot of options to have to remember to get valid tap. I
suggest that you install
<a href="http://search.cpan.org/dist/TAP-Parser-SourceHandler-MyTAP">TAP::Parser::SourceHandler::MyTAP</a>
instead and just use its <a href="http://search.cpan.org/perldoc?my_prove"><code class="highlighter-rouge">my_prove</code></a>
utility:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>% my_prove -u root --database test test.sql
</code></pre>
</div>

<h1 id="using-mytap">Using MyTAP</h1>

<p>The purpose of MyTAP is to provide a wide range of testing utilities that
output TAP. TAP, or the “Test Anything Protocol”, is an emerging standard for
representing the output from unit tests. It owes its success to its format as
a simple text-based interface that allows for practical machine parsing and
high legibility for humans. TAP started life as part of the test harness for
Perl but now has implementations in C/C++, Python, PHP, JavaScript, Perl,
PostgreSQL, and now MySQL.</p>

<h2 id="i-love-it-when-a-plan-comes-together">I love it when a plan comes together</h2>

<p>Before anything else, you need a testing plan. This basically declares how
many tests your script is going to run to protect against premature failure.</p>

<p>The preferred way to do this is to declare a plan by calling the <code class="highlighter-rouge">plan()</code>
function:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT tap.plan( 42 );
</code></pre>
</div>

<p>There are rare cases when you will not know beforehand how many tests your
script is going to run. In this case, you can declare that you have no plan.
(Try to avoid using this as it weakens your test.)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>CALL tap.no_plan();
</code></pre>
</div>

<p>Often, though, you’ll be able to calculate the number of tests, like so:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT plan( COUNT(*) )
  FROM foo;
</code></pre>
</div>

<p>At the end of your script, you should always tell MyTAP that the tests have
completed, so that it can output any diagnostics about failures or a
discrepancy between the planned number of tests and the number actually run:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>CALL tap.finish();
</code></pre>
</div>

<h2 id="test-names">Test names</h2>

<p>By convention, each test is assigned a number in order. This is largely done
automatically for you. However, it’s often very useful to assign a name to
each test. Would you rather see this?</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ok 4
  not ok 5
  ok 6
</code></pre>
</div>

<p>Or this?</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  ok 4 - basic multi-variable
  not ok 5 - simple exponential
  ok 6 - force == mass * acceleration
</code></pre>
</div>

<p>The latter gives you some idea of what failed. It also makes it easier to find
the test in your script, simply search for “simple exponential”.</p>

<p>Many test functions take a name argument. It’s optional, but highly suggested
that you use it.</p>

<h2 id="im-ok-youre-not-ok">I’m ok, you’re not ok</h2>

<p>The basic purpose of MyTAP–and of any TAP-emitting test framework, for that
matter–is to print out either “ok #” or “not ok #”, depending on whether a
given test succeeded or failed. Everything else is just gravy.</p>

<p>All of the following functions return “ok” or “not ok” depending on whether
the test succeeded or failed.</p>

<h3 id="ok-boolean-description-"><code class="highlighter-rouge">ok( boolean, description )</code></h3>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT tap.ok( @this = @that, @description );
</code></pre>
</div>

<p>This function simply evaluates any expression (<code class="highlighter-rouge">@this = @that</code> is just a
simple example) and uses that to determine if the test succeeded or failed. A
true expression passes, a false one fails. Very simple.</p>

<p>For example:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT tap.ok( 9 ^ 2 = 81,    'simple exponential' );
SELECT tap.ok( 9 &lt; 10,        'simple comparison' );
SELECT tap.ok( 'foo' ~ '^f',  'simple regex' );
SELECT tap.ok( active,        concat(name, ' widget active' ))
  FROM widgets;
</code></pre>
</div>

<p>(Mnemonic:  “This is ok.”)</p>

<p>The <code class="highlighter-rouge">@description</code> is a very short description of the test that will be printed
out. It makes it very easy to find a test in your script when it fails and
gives others an idea of your intentions. The description is optional, but we
<em>very</em> strongly encourage its use.</p>

<p>Should an <code class="highlighter-rouge">ok()</code> fail, it will produce some diagnostics:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>not ok 18 - sufficient mucus
#     Failed test 18: "sufficient mucus"
</code></pre>
</div>

<p>Furthermore, should the boolean test result argument be passed as a <code class="highlighter-rouge">NULL</code>,
<code class="highlighter-rouge">ok()</code> will assume a test failure and attach an additional diagnostic:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>not ok 18 - sufficient mucus
#     Failed test 18: "sufficient mucus"
#     (test result was NULL)
</code></pre>
</div>

<h3 id="eq-anyelement-anyelement-description-"><code class="highlighter-rouge">eq( anyelement, anyelement, description )</code></h3>
<h3 id="isnt_eq-anyelement-anyelement-description-"><code class="highlighter-rouge">isnt_eq( anyelement, anyelement, description )</code></h3>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT tap.eq(   @this, @that, @description );
SELECT tap.not_eq( @this, @that, @description );
</code></pre>
</div>

<p>Similar to <code class="highlighter-rouge">ok()</code>, <code class="highlighter-rouge">eq()</code> and <code class="highlighter-rouge">not_eq()</code> compare their two arguments with <code class="highlighter-rouge">=</code>
AND <code class="highlighter-rouge">&lt;&gt;</code>, respectively, and use the result of that to determine if the test
succeeded or failed. So these:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>-- Is the ultimate answer 42?
SELECT tap.eq( ultimate_answer(), 42, 'Meaning of Life' );

-- foo() doesn't return empty
SELECT tap.not_eq( foo(), '', 'Got some foo' );
</code></pre>
</div>

<p>are similar to these:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT tap.ok(   ultimate_answer() =  42, 'Meaning of Life' );
SELECT tap.isnt( foo()             &lt;&gt; '', 'Got some foo'    );
</code></pre>
</div>

<p>(Mnemonic: “This is that.” “This isn’t that.”)</p>

<p><em>Note:</em> <code class="highlighter-rouge">NULL</code>s are not treated as unknowns by <code class="highlighter-rouge">eq()</code> or <code class="highlighter-rouge">not_eq()</code>. That
is, if <code class="highlighter-rouge">@this</code> and <code class="highlighter-rouge">@that</code> are both <code class="highlighter-rouge">NULL</code>, the test will pass, and if only
one of them is <code class="highlighter-rouge">NULL</code>, the test will fail.</p>

<p>So why use these test functions? They produce better diagnostics on failure.
<code class="highlighter-rouge">ok()</code> cannot know what you are testing for (beyond the description), but
<code class="highlighter-rouge">eq()</code> and <code class="highlighter-rouge">not_eq()</code> know what the test was and why it failed. For
example this test:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT tap.eq( 'waffle', 'yarblokos', 'Is foo the same as bar?' );
</code></pre>
</div>

<p>Will produce something like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code># Failed test 17:  "Is foo the same as bar?"
#         have: waffle
#         want: yarblokos
</code></pre>
</div>

<p>So you can figure out what went wrong without re-running the test.</p>

<p>You are encouraged to use <code class="highlighter-rouge">eq()</code> and <code class="highlighter-rouge">not_eq()</code> over <code class="highlighter-rouge">ok()</code> where
possible.</p>

<h3 id="matches-anyelement-regex-description-"><code class="highlighter-rouge">matches( anyelement, regex, description )</code></h3>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT matches( @this, '^that', @description );
</code></pre>
</div>

<p>Similar to <code class="highlighter-rouge">eq()</code>, <code class="highlighter-rouge">matches()</code> matches <code class="highlighter-rouge">@this</code> against the regex <code class="highlighter-rouge">/^that/</code>.</p>

<p>So this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT matches( @this, '^that', 'this is like that' );
</code></pre>
</div>

<p>is similar to:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT ok( @this REGEXP '^that', 'this is like that' );
</code></pre>
</div>

<p>(Mnemonic “This matches that”.)</p>

<p>Its advantages over <code class="highlighter-rouge">ok()</code> are similar to that of <code class="highlighter-rouge">eq()</code> and <code class="highlighter-rouge">not_eq()</code>: Better
diagnostics on failure.</p>

<h3 id="doesnt_match-anyelement-regex-description-"><code class="highlighter-rouge">doesnt_match( anyelement, regex, description )</code></h3>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT doesnt_match( @this, '^that', @description );
</code></pre>
</div>

<p>This functions works exactly as <code class="highlighter-rouge">matches()</code> does, only it checks if <code class="highlighter-rouge">@this</code>
<em>does not</em> match the given pattern.</p>

<h3 id="alike-anyelement-pattern-description-"><code class="highlighter-rouge">alike( anyelement, pattern, description )</code></h3>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT alike( @this, 'that%', @description );
</code></pre>
</div>

<p>Similar to <code class="highlighter-rouge">matches()</code>, <code class="highlighter-rouge">alike()</code> matches <code class="highlighter-rouge">@this</code> against the SQL <code class="highlighter-rouge">LIKE</code>
pattern ‘that%’. So this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT alike( @this, 'that%', 'this is alike that' );
</code></pre>
</div>

<p>is similar to:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT ok( @this LIKE 'that%', 'this is like that' );
</code></pre>
</div>

<p>(Mnemonic “This is like that”.)</p>

<p>Its advantages over <code class="highlighter-rouge">ok()</code> are similar to that of <code class="highlighter-rouge">eq()</code> and <code class="highlighter-rouge">not_eq()</code>:
Better diagnostics on failure.</p>

<h3 id="unalike-anyelement-pattern-description-"><code class="highlighter-rouge">unalike( anyelement, pattern, description )</code></h3>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT unalike( @this, 'that%', @description );
</code></pre>
</div>

<p>Works exactly as <code class="highlighter-rouge">alike()</code>, only it checks if <code class="highlighter-rouge">@this</code> <em>does not</em> match the
given pattern.</p>

<h3 id="pass-description-"><code class="highlighter-rouge">pass( description )</code></h3>
<h3 id="fail-description-"><code class="highlighter-rouge">fail( description )</code></h3>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT tap.pass( @description );
SELECT tap.fail( @description );
</code></pre>
</div>

<p>Sometimes you just want to say that the tests have passed. Usually the case is
you’ve got some complicated condition that is difficult to wedge into an
<code class="highlighter-rouge">ok()</code>. In this case, you can simply use <code class="highlighter-rouge">pass()</code> (to declare the test ok) or
<code class="highlighter-rouge">fail()</code> (for not ok). They are synonyms for <code class="highlighter-rouge">ok(1, @description)</code> and
<code class="highlighter-rouge">ok(0, @description)</code>.</p>

<p>Use these functions very, very, very sparingly.</p>

<h2 id="the-schema-things">The Schema Things</h2>

<p>Need to make sure that your database is designed just the way you think it
should be? Use these test functions and rest easy.</p>

<p>A note on comparisons: MyTAP uses a simple equivalence test (<code class="highlighter-rouge">=</code>) to compare
identifier names.</p>

<h3 id="has_table-database-table-description-"><code class="highlighter-rouge">has_table( database, table, description )</code></h3>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT has_table(DATABASE(), 'sometable', 'I got sometable');
</code></pre>
</div>

<p>This function tests whether a table exists in a database. The first
argument is a database name, the second is a table name, and the third is the
test description. If you want to test for a table in the current database, use
the <code class="highlighter-rouge">DATABASE()</code> function to specify the current databasen name. If you omit
the test description, it will be set to “Table ‘:database’.’:table’ should
exist”.</p>

<p><code class="highlighter-rouge">__hasnt_table( database, table, description )</code> checks if the table does NOT exist.</p>

<h3 id="has_column-database-table-column-description-"><code class="highlighter-rouge">has_column( database, table, column, description )</code></h3>

<p>This function tests whether the column exists in the given table of the database.</p>

<p><code class="highlighter-rouge">hasnt_column( database, table, column, description )</code> checks if the column does NOT exist</p>

<h3 id="col_is_null-database-table-column-description-"><code class="highlighter-rouge">col_is_null( database, table, column, description )</code></h3>

<p>This function tests if the column has the attribute ‘allow null’.</p>

<p><code class="highlighter-rouge">col_isnt_null( database, table, column, description )</code> checks if the column does NOT have the attribut ‘allow null’.</p>

<h3 id="col_has_primary_key-database-table-column-description-"><code class="highlighter-rouge">col_has_primary_key( database, table, column, description )</code></h3>

<p>This function tests if the column is part of a primary key.</p>

<p><code class="highlighter-rouge">col_hasnt_primary_key( database, table, column, description )</code> checks if the column is NOT part of a primary key.</p>

<h3 id="col_has_index_key-database-table-column-description-"><code class="highlighter-rouge">col_has_index_key( database, table, column, description )</code></h3>

<p>This function tests if the column is part of a key, not a primary key.</p>

<p><code class="highlighter-rouge">col_hasnt_index_key( database, table, column, description )</code> checks if this column is NOT part of a key.</p>

<h3 id="col_has_named_index-database-table-column-keyname-description-"><code class="highlighter-rouge">col_has_named_index( database, table, column, keyname, description )</code></h3>

<p>This function tests if the column is part of a key with a specific name.</p>

<p><code class="highlighter-rouge">col_has_named_index( database, table, column, keyname, description )</code> checks if the column is NOT part of a key with a specific name.</p>

<h3 id="col_has_pos_in_named_index-database-table-column-keyname-position-description-"><code class="highlighter-rouge">col_has_pos_in_named_index( database, table, column, keyname, position, description )</code></h3>

<p>This function tests if the column has the given position in a composite index of the given name. A composite index is an index on multiple columns.</p>

<p><code class="highlighter-rouge">col_hasnt_pos_in_named_index( database, table, column, keyname, position, description )</code> checks if the column does NOT have the given position in the given index.</p>

<h3 id="col_has_type-database-table-column-type-description-"><code class="highlighter-rouge">col_has_type( database, table, column, type, description )</code></h3>

<p>This function tests if the column has the given datatype.</p>

<p><code class="highlighter-rouge">col_hasnt_type( database, table, column, type, description )</code> checks if the column does NOT have the given datatype.</p>

<h3 id="col_has_default-database-table-column-description-"><code class="highlighter-rouge">col_has_default( database, table, column, description )</code></h3>

<p>This function tests if the column has a default value. Note, this function does NOT tests the actual default value, just that the attribute of a default value is set.</p>

<p><code class="highlighter-rouge">col_hasnt_default( database, table, column, description )</code> checks if the column does NOT have the ‘default’ attribute set.</p>

<h3 id="col_default_is-database-table-column-default-description-"><code class="highlighter-rouge">col_default_is( database, table, column, default, description )</code></h3>

<p>This function tests if the column has the given default value. 
<strong>Note</strong>: MySQL 5.5x does not distinguish between ‘no default’ and 
‘null as default’ and ‘empty string as default’.</p>

<h3 id="col_extra_is-database-table-column-extra-description-"><code class="highlighter-rouge">col_extra_is( database, table, column, extra, description )</code></h3>

<p>This function tests if the column has the given extra attributes. Examples of ‘extra’ are <code class="highlighter-rouge">on update current timestamp</code>.</p>

<h3 id="has_function-database-function-description-"><code class="highlighter-rouge">has_function( database, function, description )</code></h3>

<p>This function tests if the function with the given name exists in the database.</p>

<p><code class="highlighter-rouge">hasnt_function( database, function, description )</code> checks if the function with the given name does NOT exist in the database.</p>

<h3 id="has_procedure-database-procedure-description-"><code class="highlighter-rouge">has_procedure( database, procedure, description )</code></h3>

<p>This function tests if the procedure with the given name exists in the database.</p>

<p><code class="highlighter-rouge">hasnt_procedure( database, procedure, description )</code> checks if the procedure with the given name does NOT exist in the database.</p>

<h3 id="has_view--database-view-description-"><code class="highlighter-rouge">has_view ( database, view, description )</code></h3>

<p>This function tests if the view with the given name exists in the database.</p>

<p><code class="highlighter-rouge">hasnt_view ( database, view, description )</code> checks if the view with the given name does NOT exist in the database.</p>

<h3 id="has_security_invoker--database-view-description-"><code class="highlighter-rouge">has_security_invoker ( database, view, description )</code></h3>

<p>This function tests if the view has the attribute <code class="highlighter-rouge">security INVOKER</code>.</p>

<p><code class="highlighter-rouge">has_security_definer ( database, view, description )</code> checks if the view has the attribute <code class="highlighter-rouge">security DEFINER</code>.</p>

<h1 id="no-test-for-the-wicked">No Test for the Wicked</h1>

<p>There is more to MyTAP. Oh <em>so</em> much more! You can output your own
<a href="#Diagnostics">diagnostics</a>. You can write <a href="#Conditional+Tests">conditional
tests</a> based on the output of <a href="#Utility+Functions">utility
functions</a>. You can <a href="#Tap+That+Batch">batch up tests in
functions</a>. Read on to learn all about it.</p>

<h2 id="diagnostics">Diagnostics</h2>

<p>If you pick the right test function, you’ll usually get a good idea of what
went wrong when it failed. But sometimes it doesn’t work out that way. So here
we have ways for you to write your own diagnostic messages which are safer
than just <code class="highlighter-rouge">\echo</code> or <code class="highlighter-rouge">SELECT foo</code>.</p>

<h3 id="diag-text-"><code class="highlighter-rouge">diag( text )</code></h3>

<p>Returns a diagnostic message which is guaranteed not to interfere with
test output. Handy for this sort of thing:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>-- Output a diagnostic message if the collation is not en_US.UTF-8.
SELECT tap.diag(concat(
     'These tests expect CHARACTER_SET_DATABASE to be en_US.UTF-8,\n',
     'but yours is set to ', VARIABLE_VALUE, '.\n',
     'As a result, some tests may fail. YMMV.'
))
  FROM information_schema.global_variables
 WHERE VARIABLE_NAME = 'CHARACTER_SET_DATABASE'
   AND VARIABLE_VALUE &lt;&gt; 'utf-8'
</code></pre>
</div>

<p>Which would produce:</p>

<div class="highlighter-rouge"><pre class="highlight"><code># These tests expect CHARACTER_SET_DATABASE to be en_US.UTF-8,
# but yours is set to latin1.
# As a result, some tests may fail. YMMV. 
</code></pre>
</div>

<h2 id="conditional-tests">Conditional Tests</h2>

<p>Sometimes running a test under certain conditions will cause the test script
or function to die. A certain function or feature isn’t implemented (such as
<code class="highlighter-rouge">information_schema.global_variables()</code> prior to MySQL 5.1), some resource
isn’t available (like a replication), or a third party library isn’t
available. In these cases it’s necessary to skip tests, or declare that they
are supposed to fail but will work in the future (a todo test).</p>

<h3 id="skip-how_many-why-"><code class="highlighter-rouge">skip( how_many, why )</code></h3>

<p>Outputs SKIP test results. Use it in a conditional expression within a
<code class="highlighter-rouge">SELECT</code> statement to replace the output of a test that you otherwise would
have run.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT CASE WHEN mysql_version() &lt; 501000
    THEN skip(1, 'ExtractValue() not supported before 5.1' )
    ELSE ok( ExtractValue('&lt;a&gt;&lt;b/&gt;&lt;/a&gt;', 'count(/a/b)'), 'ExtractValue should work')
END;

SELECT CASE WHEN mysql_version() &lt; 501000
    THEN skip(2, 'ExtractValue() not supported before 5.1' )
    ELSE concat(
        ok( ExtractValue('&lt;a&gt;&lt;b/&gt;&lt;/a&gt;', 'count(/a/b)'), 'ExtractValue should work'),
        '\n',
        ok( ExtractValue('&lt;a&gt;&lt;b/&gt;&lt;/a&gt;', 'count(/a/b)'), 'ExtractValue should work')
    )
END;
</code></pre>
</div>

<p>Note how use of the conditional <code class="highlighter-rouge">CASE</code> statement has been used to determine
whether or not to run a couple of tests. If they are to be run, they are run
through <code class="highlighter-rouge">concat()</code>, so that we can run a few tests in the same query. If we
don’t want to run them, we call <code class="highlighter-rouge">skip()</code> and tell it how many tests we’re
skipping.</p>

<h3 id="todo-how_many-why-"><code class="highlighter-rouge">todo( how_many, why )</code></h3>

<p>Declares a series of tests that you expect to fail and why. Perhaps it’s
because you haven’t fixed a bug or haven’t finished a new feature:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT todo(2, 'URIGeller not finished');

SET card 'Eight of clubs';
SELECT eq( yourCard(), @card, 'Is THIS your card?' );
SELECT eq( bendSpoon(), 'bent', 'Spoon bending, how original' );
</code></pre>
</div>

<p>With <code class="highlighter-rouge">todo()</code>, <code class="highlighter-rouge">@how_many</code> specifies how many tests are expected to fail.
pgTAP will run the tests normally, but print out special flags indicating they
are “todo” tests. The test harness will interpret these failures as ok. Should
any todo test pass, the harness will report it as an unexpected success. You
then know that the thing you had todo is done and can remove the call to
<code class="highlighter-rouge">todo()</code>.</p>

<p>The nice part about todo tests, as opposed to simply commenting out a block of
tests, is that they’re like a programmatic todo list. You know how much work
is left to be done, you’re aware of what bugs there are, and you’ll know
immediately when they’re fixed.</p>

<h3 id="todo_start-why-"><code class="highlighter-rouge">todo_start( why )</code></h3>

<p>This function allows you declare all subsequent tests as TODO tests, up until
the <code class="highlighter-rouge">todo_end()</code> function is called.</p>

<p>The <code class="highlighter-rouge">todo()</code> syntax is generally pretty good about figuring out whether or not
we’re in a TODO test. However, often we find it difficult to specify the
<em>number</em> of tests that are TODO tests. Thus, you can instead use
<code class="highlighter-rouge">todo_start()</code> and <code class="highlighter-rouge">todo_end()</code> to more easily define the scope of your TODO
tests.</p>

<p>Note that you can nest TODO tests, too:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT todo_start('working on this');
-- lots of code
SELECT todo_start('working on that');
-- more code
SELECT todo_end();
SELECT todo_end();
</code></pre>
</div>

<p>This is generally not recommended, but large testing systems often have weird
internal needs.</p>

<p>The <code class="highlighter-rouge">todo_start()</code> and <code class="highlighter-rouge">todo_end()</code> function should also work with the
<code class="highlighter-rouge">todo()</code> function, although it’s not guaranteed and its use is also
discouraged:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT todo_start('working on this');
-- lots of code
SELECT todo(2, 'working on that');
-- Two tests for which the above line applies
-- Followed by more tests scoped till the following line.
SELECT todo_end();
</code></pre>
</div>

<p>We recommend that you pick one style or another of TODO to be on the safe
side.</p>

<h3 id="todo_end">todo_end()</h3>

<p>Stops running tests as TODO tests. This function is fatal if called without a
preceding <code class="highlighter-rouge">todo_start()</code> method call.</p>

<h3 id="in_todo">in_todo()</h3>

<p>Returns true if the test is currently inside a TODO block.</p>

<h2 id="utility-functions">Utility Functions</h2>

<p>Along with the usual array of testing, planning, and diagnostic functions,
pTAP provides a few extra functions to make the work of testing more pleasant.</p>

<h3 id="mytap_version"><code class="highlighter-rouge">mytap_version()</code></h3>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT mytap_version();
</code></pre>
</div>

<p>Returns the version of MyTAP installed in the server. The value is <code class="highlighter-rouge">NUMERIC</code>,
and thus suitable for comparing to a decimal value.</p>

<h3 id="mysql_version"><code class="highlighter-rouge">mysql_version()</code></h3>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT mysql_version();
</code></pre>
</div>

<p>Returns an integer representation of the server version number. This function
is useful for determining whether or not certain tests should be run or
skipped (using <code class="highlighter-rouge">skip()</code>) depending on the version of MySQL. For example:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT CASE WHEN mysql_version() &lt; 501000
    THEN skip('ExtractValue() not supported before 5.1' )
    ELSE ok( ExtractValue('&lt;a&gt;&lt;b/&gt;&lt;/a&gt;', 'count(/a/b)'), 'ExtractValue should work')
END;
</code></pre>
</div>

<p>The revision level is in the hundres position, the minor version in the ten
thousands position, and the major version in the hundred thousands position
and above (assuming MySQL 10 is ever released, it will be in the millions
position).</p>

<h1 id="compose-yourself">Compose Yourself</h1>

<p>So, you’ve been using MyTAP for a while, and now you want to write your own
test functions. Go ahead; I don’t mind. In fact, I encourage it. How? Why,
by providing a function you can use to test your tests, of course!</p>

<p>But first, a brief primer on writing your own test functions. There isn’t much
to it, really. Just write your function to do whatever comparison you want. As
long as you have a boolean value indicating whether or not the test passed,
you’re golden. Just then use <code class="highlighter-rouge">ok()</code> to ensure that everything is tracked
appropriately by a test script.</p>

<p>For example, say that you wanted to create a function to ensure that two text
values always compare case-insensitively. Sure you could do this with
<code class="highlighter-rouge">eq()</code> and the <code class="highlighter-rouge">LOWER()</code> function, but if you’re doing this all the time,
you might want to simplify things. Here’s how to go about it:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>DROP FUNCTION IF EXITS lc_is
DELIMITER //
CREATE FUNCTION lc_is (have TEXT, want TEXT, descr TEXT)
RETURNS TEXT
BEGIN
    IF LOWER(have) = LOWER(want) THEN
        RETURN ok(1, descr);
    END IF;
    RETURN concat(ok( 0, descr ), '\n', diag(concat(
           '    Have: ', have,
         '\n    Want: ', want
    )));
END //

DELIMITER ;
</code></pre>
</div>

<p>Yep, that’s it. The key is to always use MyTAP’s <code class="highlighter-rouge">ok()</code> function to guarantee
that the output is properly formatted, uses the next number in the sequence,
and the results are properly recorded in the database for summarization at
the end of the test script. You can also provide diagnostics as appropriate;
just append them to the output of <code class="highlighter-rouge">ok()</code> as we’ve done here.</p>

<p>Of course, you don’t have to directly use <code class="highlighter-rouge">ok()</code>; you can also use another
MyTAP function that ultimately calls <code class="highlighter-rouge">ok()</code>. IOW, while the above example
is instructive, this version is easier on the eyes:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>CREATE FUNCTION lc_is ( have TEXT, want TEXT, descr TEXT )
RETURNS TEXT
BEGIN
     RETURN eq( LOWER(have), LOWER(want), descr);
END //
</code></pre>
</div>

<p>But either way, let MyTAP handle recording the test results and formatting the
output.</p>

<h2 id="testing-test-functions">Testing Test Functions</h2>

<p>Now you’ve written your test function. So how do you test it? Why, with this
handy-dandy test function!</p>

<h3 id="check_test-test_output-is_ok-name-want_description-want_diag-match_diag-"><code class="highlighter-rouge">check_test( test_output, is_ok, name, want_description, want_diag, match_diag )</code></h3>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT check_test(
    lc_eq('This', 'THAT', 'not eq'),
    0,
    'lc_eq fail',
    'not eq',
    '    Want: this\n    Have: that'
);

SELECT check_test(
    lc_eq('This', 'THIS', 'eq'),
    1
);
</code></pre>
</div>

<p>This function runs anywhere between one and three tests against a test
function. For the impatient, the arguments are:</p>

<ul>
  <li><code class="highlighter-rouge">@test_output</code> - The output from your test. Usually it’s just returned by a
call to the test function itself. Required.</li>
  <li><code class="highlighter-rouge">@is_ok</code> - Boolean indicating whether or not the test is expected to pass.
Required.</li>
  <li><code class="highlighter-rouge">@name</code> - A brief name for your test, to make it easier to find failures in
your test script. Optional.</li>
  <li><code class="highlighter-rouge">@want_description</code> - Expected test description to be output by the test.
Optional. Use an empty string to test that no description is output.</li>
  <li><code class="highlighter-rouge">@want_diag</code> - Expected diagnostic message output during the execution of
a test. Must always follow whatever is output by the call to <code class="highlighter-rouge">ok()</code>.
Optional. Use an empty string to test that no description is output.</li>
  <li><code class="highlighter-rouge">@match_diag</code> - Use <code class="highlighter-rouge">matches()</code> to compare the diagnostics rather than
<code class="highlighter-rouge">@eq()</code>. Useful for those situations where you’re not sure what will be
in the output, but you can match it with a regular expression.</li>
</ul>

<p>Now, on with the detailed documentation. At its simplest, you just pass in the
output of your test function (and it must be one and <strong>only one</strong> test
function’s output, or you’ll screw up the count, so don’t do that!) and a
boolean value indicating whether or not you expect the test to have passed.
That looks something like the second example above.</p>

<p>All other arguments are optional, but I recommend that you <em>always</em> include a
short test name to make it easier to track down failures in your test script.
<code class="highlighter-rouge">check_test()</code> uses this name to construct descriptions of all of the tests it
runs. For example, without a short name, the above example will yield output
like so:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>not ok 14 - Test should pass
</code></pre>
</div>

<p>Yeah, but which test? So give it a very succinct name and you’ll know what
test. If you have a lot of these, it won’t be much help. So give each call
to <code class="highlighter-rouge">check_test()</code> a name:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT check_test(
    lc_eq('This', 'THIS', 'eq'),
    true,
    'Simple lc_eq test',
);
</code></pre>
</div>

<p>Then you’ll get output more like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>not ok 14 - Simple lc_test should pass
</code></pre>
</div>

<p>Which will make it much easier to find the failing test in your test script.</p>

<p>The optional fourth argument is the description you expect to be output. This
is especially important if your test function generates a description when
none is passed to it. You want to make sure that your function generates the
test description you think it should! This will cause a second test to be run
on your test function. So for something like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT check_test(
    lc_eq( ''this'', ''THIS'' ),
    true,
    'lc_eq() test',
    'this is THIS'
);
</code></pre>
</div>

<p>The output then would look something like this, assuming that the <code class="highlighter-rouge">lc_eq()</code>
function generated the proper description (the above example does not):</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ok 42 - lc_eq() test should pass
ok 43 - lc_eq() test should have the proper description
</code></pre>
</div>

<p>See how there are two tests run for a single call to <code class="highlighter-rouge">check_test()</code>? Be sure
to adjust your plan accordingly. Also note how the test name was used in the
descriptions for both tests.</p>

<p>If the test had failed, it would output a nice diagnostics. Internally it just
uses <code class="highlighter-rouge">eq()</code> to compare the strings:</p>

<div class="highlighter-rouge"><pre class="highlight"><code># Failed test 43:  "lc_eq() test should have the proper description"
#         have: 'this is this'
#         want: 'this is THIS'
</code></pre>
</div>

<p>The fifth argument, <code class="highlighter-rouge">@want_diag</code>, which is also optional, compares the
diagnostics generated during the test to an expected string. Such diagnostics
<strong>must</strong> follow whatever is output by the call to <code class="highlighter-rouge">ok()</code> in your test. Your
test function should not call <code class="highlighter-rouge">diag()</code> until after it calls <code class="highlighter-rouge">ok()</code> or things
will get truly funky.</p>

<p>Assuming you’ve followed that rule in your <code class="highlighter-rouge">lc_eq()</code> test function, see what
happens when a <code class="highlighter-rouge">lc_eq()</code> fails. Write your test to test the diagnostics like
so:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT * FROM check_test(
    lc_eq( ''this'', ''THat'' ),
    false,
    'lc_eq() failing test',
    'this is THat',
    '    Want: this\n    Have: THat
);
</code></pre>
</div>

<p>This of course triggers a third test to run. The output will look like so:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ok 44 - lc_eq() failing test should fail
ok 45 - lc_eq() failing test should have the proper description
ok 46 - lc_eq() failing test should have the proper diagnostics
</code></pre>
</div>

<p>And of course, it the diagnostic test fails, it will output diagnostics just
like a description failure would, something like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code># Failed test 46:  "lc_eq() failing test should have the proper diagnostics"
#         have:     Have: this
#     Want: that
#         want:     Have: this
#     Want: THat
</code></pre>
</div>

<p>If you pass in the optional sixth argument, <code class="highlighter-rouge">@match_diag</code>, the <code class="highlighter-rouge">@want_diag</code>
argument will be compared to the actual diagnostic output using <code class="highlighter-rouge">matches()</code>
instead of <code class="highlighter-rouge">eq()</code>. This allows you to use a regular expression in the
<code class="highlighter-rouge">@want_diag</code> argument to match the output, for those situations where some
part of the output might vary, such as time-based diagnostics.</p>

<p>I realize that all of this can be a bit confusing, given the various haves and
wants, but it gets the job done. Of course, if your diagnostics use something
other than indented “have” and “want”, such failures will be easier to read.
But either way, <em>do</em> test your diagnostics!</p>

<h2 id="to-do">To Do</h2>

<ul>
  <li>Port lot of other assertion functions from <a href="http://pgtap.org/">pgTAP</a>.</li>
</ul>

<h2 id="public-repository">Public Repository</h2>

<p>The source code for MyTAP is available on
<a href="http://github.com/hepabolu/mytap/">GitHub</a>. Please feel free to fork and
contribute!</p>

<h2 id="authors">Authors</h2>

<ul>
  <li><a href="http://justatheory.com/">David E. Wheeler</a></li>
  <li><a href="https://github.com/hepabolu/mytap">Hepabolu</a></li>
</ul>

<h2 id="credits">Credits</h2>

<ul>
  <li>Michael Schwern and chromatic for Test::More.</li>
  <li>Adrian Howard for Test::Exception.</li>
</ul>

<h2 id="copyright-and-license">Copyright and License</h2>

<p>Copyright (c) 2010 David E. Wheeler. Some rights reserved.</p>

<p>Permission to use, copy, modify, and distribute this software and its
documentation for any purpose, without fee, and without a written agreement is
hereby granted, provided that the above copyright notice and this paragraph
and the following two paragraphs appear in all copies.</p>

<p>IN NO EVENT SHALL KINETICODE BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF KINETICODE HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>

<p>KINETICODE SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON AN “AS IS” BASIS, AND
KINETICODE HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
ENHANCEMENTS, OR MODIFICATIONS.</p>



      </section>
      <footer>
        
        <p>This project is maintained by <a href="http://github.com/hepabolu">hepabolu</a></p>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>


  
  </body>
</html>
